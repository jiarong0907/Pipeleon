import os
import sys
from copy import deepcopy
from graph_optimizer.json_manager import JsonPlanner, CopyManager

sys.path.insert(0, os.path.abspath("./src"))

from graph_optimizer.options import *
from graph_optimizer.pipelet import Pipelet, PipeletGroup
from commons.metric import MetricParams
from commons.base_logging import logger
from graph_optimizer.opt_utils import OptUtils


class PlanEvaluator:
    """Evaluate the cost and gain of optimization plans generated by the planner"""

    @staticmethod
    def _eval_pipelet_option(pipelet_option: PipeletOption):
        """Compute the optimization gain and cost of a PipeletOption"""
        original_pipelet = pipelet_option.pipelet
        pipelet_copy = CopyManager._copy_pipelet(original_pipelet)
        JsonPlanner.apply_reordering(pipelet_copy, pipelet_option.new_order)
        # only the reorder option
        if pipelet_option.combined_options == None:
            PlanEvaluator._calculate_gain_cost_pipelet(
                original_pipelet, pipelet_copy, pipelet_option, only_reorder=True
            )
            return
        for op in pipelet_option.combined_options:
            if isinstance(op, SegmentOptimizationOption):
                JsonPlanner.apply_segment_opt(pipelet_copy, op)
            else:
                raise Exception("Unrecognized optimization option!")

        PlanEvaluator._calculate_gain_cost_pipelet(original_pipelet, pipelet_copy, pipelet_option, only_reorder=False)

    @staticmethod
    def _calculate_gain_cost_pipelet(
        original_pipelet: Pipelet, optimized_pipelet: Pipelet, pipelet_option: PipeletOption, only_reorder: bool
    ):
        """Invoke the cost model to compute the optimization gain and cost"""
        logger.debug("Computing gain and cost....")
        # create a copy of the original pipelet for resplit
        # the orginal one will be by other optimization options
        if original_pipelet.irgraph_pipe.eval_metric is None:
            # re-split the original pipelet before we evaluate it
            logger.debug("deepcopying....")
            pipelet_original_copy = CopyManager._copy_pipelet(original_pipelet)
            JsonPlanner._resplit_irg_pipe(pipelet_original_copy.irgraph_pipe)
            logger.debug("Evaluating original....")
            original_eval_metric = pipelet_original_copy.irgraph_pipe.eval()
            original_pipelet.irgraph_pipe.eval_metric = original_eval_metric
        else:
            original_eval_metric = original_pipelet.irgraph_pipe.eval_metric
        logger.debug(original_eval_metric)
        logger.debug("respliting....")
        JsonPlanner._resplit_irg_pipe(optimized_pipelet.irgraph_pipe)
        logger.debug("Evaluating optimized....")
        new_eval_metric = optimized_pipelet.irgraph_pipe.eval()
        logger.debug(new_eval_metric)
        delta: MetricParams = new_eval_metric - original_eval_metric
        pipelet_option.mcost = 0 if only_reorder else delta._memory_used
        pipelet_option.icost = 0 if only_reorder else delta._entry_insertion_rate

        # When merged table size is very small, the generated table could have negative
        # mcost, which causes bugs for DP search, so we set the minimal value to 1
        if pipelet_option.mcost < 0:
            pipelet_option.mcost = 1

        # pipelet_option.lgain = -1*(0.5*delta._median_latency + 0.5*delta._p99_latency)
        # To make the computation of lgain and tgain use the same latency
        pipelet_option.lgain = -1 * delta._average_latency
        pipelet_option.tgain = -1.0 * delta._inter_packet_gap
        logger.info(f"lgain: {pipelet_option.lgain}, tgain: {pipelet_option.tgain}")

    @staticmethod
    def _eval_pipelet_group_option(pipe_grp_option: PipeletGroupOption):
        """Compute the optimization gain and cost of a PipeletGroupOption
        with GroupMergeOption
        """
        pipelet_options = pipe_grp_option.pipelet_options
        grp_options = pipe_grp_option.group_options
        # Only has pipelet options, we can sum up the pipelet option costs and gains
        if grp_options is None:
            assert pipelet_options is not None, f"pipelet_options is None when the group_options is also None."
            pipe_grp_option.mcost = sum([p.mcost for p in pipelet_options])
            pipe_grp_option.icost = sum([p.icost for p in pipelet_options])
            pipe_grp_option.lgain = sum([p.lgain for p in pipelet_options])
            pipe_grp_option.tgain = sum([p.tgain for p in pipelet_options])
            return

        assert len(grp_options) == 1, (
            f"The group option should have a GroupMergeOption, " f"but got {type(grp_options[0])}"
        )

        original_pipe_grp = pipe_grp_option.pipelet_group
        pipe_grp_copy = deepcopy(original_pipe_grp)
        if isinstance(grp_options[0], GroupMergeOption):
            JsonPlanner.apply_group_merge(pipe_grp_copy, grp_options[0])
        elif isinstance(grp_options[0], GroupCacheOption):
            JsonPlanner.apply_group_cache(pipe_grp_copy)
        else:
            raise TypeError(f"Unrecognized group option type {type(grp_options[0])}")
        PlanEvaluator._calculate_gain_cost_pipelet_group(original_pipe_grp, pipe_grp_copy, pipe_grp_option)

    @staticmethod
    def _calculate_gain_cost_pipelet_group(
        original_pipe_grp: PipeletGroup, optimized_pipe_grp: PipeletGroup, pipe_grp_option: PipeletGroupOption
    ):
        """Invoke the cost model to compute the optimization gain and cost"""
        # create a copy of the original pipelet for resplit
        # the orginal one will be by other optimization options
        if original_pipe_grp.irgraph_pipe.eval_metric is None:
            # re-split the original pipelet before we evaluate it
            pipe_grp_original_copy = deepcopy(original_pipe_grp)
            JsonPlanner._resplit_irg_pipe(pipe_grp_original_copy.irgraph_pipe)
            original_eval_metric = pipe_grp_original_copy.irgraph_pipe.eval()
            original_pipe_grp.irgraph_pipe.eval_metric = original_eval_metric
        else:
            original_eval_metric = original_pipe_grp.irgraph_pipe.eval_metric
        logger.debug(original_eval_metric)

        JsonPlanner._resplit_irg_pipe(optimized_pipe_grp.irgraph_pipe)
        new_eval_metric = optimized_pipe_grp.irgraph_pipe.eval()
        logger.debug(new_eval_metric)
        delta: MetricParams = new_eval_metric - original_eval_metric
        pipe_grp_option.mcost = delta._memory_used
        pipe_grp_option.icost = delta._entry_insertion_rate

        # When merged table size is very small, the generated table could have negative
        # mcost, which causes bugs for DP search, so we set the minimal value to 1
        if pipe_grp_option.mcost < 0:
            pipe_grp_option.mcost = 1

        pipe_grp_option.lgain = -1 * delta._average_latency
        pipe_grp_option.tgain = -1.0 * delta._inter_packet_gap
        logger.info(f"lgain: {pipe_grp_option.lgain}, tgain: {pipe_grp_option.tgain}")
